{
  "version": 3,
  "sources": [
    "../../../../../Users/bglebov/AppData/Roaming/npm/node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "C:\\git\\letscutit\\gui\\node_modules\\av\\browser_slim.coffee",
    "src/asset.js",
    "src/aurora_base.js",
    "src/core/base.js",
    "src/core/bitstream.js",
    "src/core/buffer.js",
    "src/core/bufferlist.js",
    "src/core/events.js",
    "src/core/stream.js",
    "src/core/underflow.js",
    "src/decoder.js",
    "src/demuxer.js",
    "src/device.js",
    "src/devices/mozilla.js",
    "src/devices/resampler.js",
    "src/devices/webaudio.js",
    "src/filter.js",
    "src/filters/balance.js",
    "src/filters/volume.js",
    "src/player.js",
    "src/queue.js",
    "C:\\git\\letscutit\\gui\\node_modules\\av\\src\\sources\\browser\\file.coffee",
    "C:\\git\\letscutit\\gui\\node_modules\\av\\src\\sources\\browser\\http.coffee",
    "src/sources/buffer.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA,IAAA,cAAA;;AAAA;AAAA,KAAA,WAAA;kBAAA;AACE,EAAA,OAAQ,CAAA,GAAA,CAAR,GAAe,GAAf,CADF;AAAA,CAAA;;AAAA,OAGA,CAAQ,wBAAR,CAHA,CAAA;;AAAA,OAIA,CAAQ,uBAAR,CAJA,CAAA;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACnOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA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",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "for key, val of require './src/aurora_base'\n  exports[key] = val\n  \nrequire './src/devices/webaudio'\nrequire './src/devices/mozilla'\n",
    "// Generated by CoffeeScript 1.10.0\n(function() {\n  var Asset, BufferSource, Decoder, Demuxer, EventEmitter, FileSource, HTTPSource,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  EventEmitter = require('./core/events');\n\n  HTTPSource = require('./sources/node/http');\n\n  FileSource = require('./sources/node/file');\n\n  BufferSource = require('./sources/buffer');\n\n  Demuxer = require('./demuxer');\n\n  Decoder = require('./decoder');\n\n  Asset = (function(superClass) {\n    extend(Asset, superClass);\n\n    function Asset(source) {\n      this.source = source;\n      this._decode = bind(this._decode, this);\n      this.findDecoder = bind(this.findDecoder, this);\n      this.probe = bind(this.probe, this);\n      this.buffered = 0;\n      this.duration = null;\n      this.format = null;\n      this.metadata = null;\n      this.active = false;\n      this.demuxer = null;\n      this.decoder = null;\n      this.source.once('data', this.probe);\n      this.source.on('error', (function(_this) {\n        return function(err) {\n          _this.emit('error', err);\n          return _this.stop();\n        };\n      })(this));\n      this.source.on('progress', (function(_this) {\n        return function(buffered) {\n          _this.buffered = buffered;\n          return _this.emit('buffer', _this.buffered);\n        };\n      })(this));\n    }\n\n    Asset.fromURL = function(url, opts) {\n      return new Asset(new HTTPSource(url, opts));\n    };\n\n    Asset.fromFile = function(file) {\n      return new Asset(new FileSource(file));\n    };\n\n    Asset.fromBuffer = function(buffer) {\n      return new Asset(new BufferSource(buffer));\n    };\n\n    Asset.prototype.start = function(decode) {\n      if (this.active) {\n        return;\n      }\n      if (decode != null) {\n        this.shouldDecode = decode;\n      }\n      if (this.shouldDecode == null) {\n        this.shouldDecode = true;\n      }\n      this.active = true;\n      this.source.start();\n      if (this.decoder && this.shouldDecode) {\n        return this._decode();\n      }\n    };\n\n    Asset.prototype.stop = function() {\n      if (!this.active) {\n        return;\n      }\n      this.active = false;\n      return this.source.pause();\n    };\n\n    Asset.prototype.get = function(event, callback) {\n      if (event !== 'format' && event !== 'duration' && event !== 'metadata') {\n        return;\n      }\n      if (this[event] != null) {\n        return callback(this[event]);\n      } else {\n        this.once(event, (function(_this) {\n          return function(value) {\n            _this.stop();\n            return callback(value);\n          };\n        })(this));\n        return this.start();\n      }\n    };\n\n    Asset.prototype.decodePacket = function() {\n      return this.decoder.decode();\n    };\n\n    Asset.prototype.decodeToBuffer = function(callback) {\n      var chunks, dataHandler, length;\n      length = 0;\n      chunks = [];\n      this.on('data', dataHandler = function(chunk) {\n        length += chunk.length;\n        return chunks.push(chunk);\n      });\n      this.once('end', function() {\n        var buf, chunk, j, len, offset;\n        buf = new Float32Array(length);\n        offset = 0;\n        for (j = 0, len = chunks.length; j < len; j++) {\n          chunk = chunks[j];\n          buf.set(chunk, offset);\n          offset += chunk.length;\n        }\n        this.off('data', dataHandler);\n        return callback(buf);\n      });\n      return this.start();\n    };\n\n    Asset.prototype.probe = function(chunk) {\n      var demuxer;\n      if (!this.active) {\n        return;\n      }\n      demuxer = Demuxer.find(chunk);\n      if (!demuxer) {\n        return this.emit('error', 'A demuxer for this container was not found.');\n      }\n      this.demuxer = new demuxer(this.source, chunk);\n      this.demuxer.on('format', this.findDecoder);\n      this.demuxer.on('duration', (function(_this) {\n        return function(duration) {\n          _this.duration = duration;\n          return _this.emit('duration', _this.duration);\n        };\n      })(this));\n      this.demuxer.on('metadata', (function(_this) {\n        return function(metadata) {\n          _this.metadata = metadata;\n          return _this.emit('metadata', _this.metadata);\n        };\n      })(this));\n      return this.demuxer.on('error', (function(_this) {\n        return function(err) {\n          _this.emit('error', err);\n          return _this.stop();\n        };\n      })(this));\n    };\n\n    Asset.prototype.findDecoder = function(format) {\n      var decoder, div;\n      this.format = format;\n      if (!this.active) {\n        return;\n      }\n      this.emit('format', this.format);\n      decoder = Decoder.find(this.format.formatID);\n      if (!decoder) {\n        return this.emit('error', \"A decoder for \" + this.format.formatID + \" was not found.\");\n      }\n      this.decoder = new decoder(this.demuxer, this.format);\n      if (this.format.floatingPoint) {\n        this.decoder.on('data', (function(_this) {\n          return function(buffer) {\n            return _this.emit('data', buffer);\n          };\n        })(this));\n      } else {\n        div = Math.pow(2, this.format.bitsPerChannel - 1);\n        this.decoder.on('data', (function(_this) {\n          return function(buffer) {\n            var buf, i, j, len, sample;\n            buf = new Float32Array(buffer.length);\n            for (i = j = 0, len = buffer.length; j < len; i = ++j) {\n              sample = buffer[i];\n              buf[i] = sample / div;\n            }\n            return _this.emit('data', buf);\n          };\n        })(this));\n      }\n      this.decoder.on('error', (function(_this) {\n        return function(err) {\n          _this.emit('error', err);\n          return _this.stop();\n        };\n      })(this));\n      this.decoder.on('end', (function(_this) {\n        return function() {\n          return _this.emit('end');\n        };\n      })(this));\n      this.emit('decodeStart');\n      if (this.shouldDecode) {\n        return this._decode();\n      }\n    };\n\n    Asset.prototype._decode = function() {\n      while (this.decoder.decode() && this.active) {\n        continue;\n      }\n      if (this.active) {\n        return this.decoder.once('data', this._decode);\n      }\n    };\n\n    Asset.prototype.destroy = function() {\n      var ref, ref1, ref2;\n      this.stop();\n      if ((ref = this.demuxer) != null) {\n        ref.off();\n      }\n      if ((ref1 = this.decoder) != null) {\n        ref1.off();\n      }\n      if ((ref2 = this.source) != null) {\n        ref2.off();\n      }\n      return this.off();\n    };\n\n    return Asset;\n\n  })(EventEmitter);\n\n  module.exports = Asset;\n\n}).call(this);\n",
    "// Generated by CoffeeScript 1.10.0\n(function() {\n  exports.Base = require('./core/base');\n\n  exports.Buffer = require('./core/buffer');\n\n  exports.BufferList = require('./core/bufferlist');\n\n  exports.Stream = require('./core/stream');\n\n  exports.Bitstream = require('./core/bitstream');\n\n  exports.EventEmitter = require('./core/events');\n\n  exports.UnderflowError = require('./core/underflow');\n\n  exports.HTTPSource = require('./sources/node/http');\n\n  exports.FileSource = require('./sources/node/file');\n\n  exports.BufferSource = require('./sources/buffer');\n\n  exports.Demuxer = require('./demuxer');\n\n  exports.Decoder = require('./decoder');\n\n  exports.AudioDevice = require('./device');\n\n  exports.Asset = require('./asset');\n\n  exports.Player = require('./player');\n\n  exports.Filter = require('./filter');\n\n  exports.VolumeFilter = require('./filters/volume');\n\n  exports.BalanceFilter = require('./filters/balance');\n\n}).call(this);\n",
    "// Generated by CoffeeScript 1.10.0\n(function() {\n  var Base,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty,\n    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n  Base = (function() {\n    var fnTest;\n\n    function Base() {}\n\n    fnTest = /\\b_super\\b/;\n\n    Base.extend = function(prop) {\n      var Class, _super, fn, key, keys, ref;\n      Class = (function(superClass) {\n        extend(Class, superClass);\n\n        function Class() {\n          return Class.__super__.constructor.apply(this, arguments);\n        }\n\n        return Class;\n\n      })(this);\n      if (typeof prop === 'function') {\n        keys = Object.keys(Class.prototype);\n        prop.call(Class, Class);\n        prop = {};\n        ref = Class.prototype;\n        for (key in ref) {\n          fn = ref[key];\n          if (indexOf.call(keys, key) < 0) {\n            prop[key] = fn;\n          }\n        }\n      }\n      _super = Class.__super__;\n      for (key in prop) {\n        fn = prop[key];\n        if (typeof fn === 'function' && fnTest.test(fn)) {\n          (function(key, fn) {\n            return Class.prototype[key] = function() {\n              var ret, tmp;\n              tmp = this._super;\n              this._super = _super[key];\n              ret = fn.apply(this, arguments);\n              this._super = tmp;\n              return ret;\n            };\n          })(key, fn);\n        } else {\n          Class.prototype[key] = fn;\n        }\n      }\n      return Class;\n    };\n\n    return Base;\n\n  })();\n\n  module.exports = Base;\n\n}).call(this);\n",
    "// Generated by CoffeeScript 1.10.0\n(function() {\n  var Bitstream;\n\n  Bitstream = (function() {\n    function Bitstream(stream) {\n      this.stream = stream;\n      this.bitPosition = 0;\n    }\n\n    Bitstream.prototype.copy = function() {\n      var result;\n      result = new Bitstream(this.stream.copy());\n      result.bitPosition = this.bitPosition;\n      return result;\n    };\n\n    Bitstream.prototype.offset = function() {\n      return 8 * this.stream.offset + this.bitPosition;\n    };\n\n    Bitstream.prototype.available = function(bits) {\n      return this.stream.available((bits + 8 - this.bitPosition) / 8);\n    };\n\n    Bitstream.prototype.advance = function(bits) {\n      var pos;\n      pos = this.bitPosition + bits;\n      this.stream.advance(pos >> 3);\n      return this.bitPosition = pos & 7;\n    };\n\n    Bitstream.prototype.rewind = function(bits) {\n      var pos;\n      pos = this.bitPosition - bits;\n      this.stream.rewind(Math.abs(pos >> 3));\n      return this.bitPosition = pos & 7;\n    };\n\n    Bitstream.prototype.seek = function(offset) {\n      var curOffset;\n      curOffset = this.offset();\n      if (offset > curOffset) {\n        return this.advance(offset - curOffset);\n      } else if (offset < curOffset) {\n        return this.rewind(curOffset - offset);\n      }\n    };\n\n    Bitstream.prototype.align = function() {\n      if (this.bitPosition !== 0) {\n        this.bitPosition = 0;\n        return this.stream.advance(1);\n      }\n    };\n\n    Bitstream.prototype.read = function(bits, signed) {\n      var a, a0, a1, a2, a3, a4, mBits;\n      if (bits === 0) {\n        return 0;\n      }\n      mBits = bits + this.bitPosition;\n      if (mBits <= 8) {\n        a = ((this.stream.peekUInt8() << this.bitPosition) & 0xff) >>> (8 - bits);\n      } else if (mBits <= 16) {\n        a = ((this.stream.peekUInt16() << this.bitPosition) & 0xffff) >>> (16 - bits);\n      } else if (mBits <= 24) {\n        a = ((this.stream.peekUInt24() << this.bitPosition) & 0xffffff) >>> (24 - bits);\n      } else if (mBits <= 32) {\n        a = (this.stream.peekUInt32() << this.bitPosition) >>> (32 - bits);\n      } else if (mBits <= 40) {\n        a0 = this.stream.peekUInt8(0) * 0x0100000000;\n        a1 = this.stream.peekUInt8(1) << 24 >>> 0;\n        a2 = this.stream.peekUInt8(2) << 16;\n        a3 = this.stream.peekUInt8(3) << 8;\n        a4 = this.stream.peekUInt8(4);\n        a = a0 + a1 + a2 + a3 + a4;\n        a %= Math.pow(2, 40 - this.bitPosition);\n        a = Math.floor(a / Math.pow(2, 40 - this.bitPosition - bits));\n      } else {\n        throw new Error(\"Too many bits!\");\n      }\n      if (signed) {\n        if (mBits < 32) {\n          if (a >>> (bits - 1)) {\n            a = ((1 << bits >>> 0) - a) * -1;\n          }\n        } else {\n          if (a / Math.pow(2, bits - 1) | 0) {\n            a = (Math.pow(2, bits) - a) * -1;\n          }\n        }\n      }\n      this.advance(bits);\n      return a;\n    };\n\n    Bitstream.prototype.peek = function(bits, signed) {\n      var a, a0, a1, a2, a3, a4, mBits;\n      if (bits === 0) {\n        return 0;\n      }\n      mBits = bits + this.bitPosition;\n      if (mBits <= 8) {\n        a = ((this.stream.peekUInt8() << this.bitPosition) & 0xff) >>> (8 - bits);\n      } else if (mBits <= 16) {\n        a = ((this.stream.peekUInt16() << this.bitPosition) & 0xffff) >>> (16 - bits);\n      } else if (mBits <= 24) {\n        a = ((this.stream.peekUInt24() << this.bitPosition) & 0xffffff) >>> (24 - bits);\n      } else if (mBits <= 32) {\n        a = (this.stream.peekUInt32() << this.bitPosition) >>> (32 - bits);\n      } else if (mBits <= 40) {\n        a0 = this.stream.peekUInt8(0) * 0x0100000000;\n        a1 = this.stream.peekUInt8(1) << 24 >>> 0;\n        a2 = this.stream.peekUInt8(2) << 16;\n        a3 = this.stream.peekUInt8(3) << 8;\n        a4 = this.stream.peekUInt8(4);\n        a = a0 + a1 + a2 + a3 + a4;\n        a %= Math.pow(2, 40 - this.bitPosition);\n        a = Math.floor(a / Math.pow(2, 40 - this.bitPosition - bits));\n      } else {\n        throw new Error(\"Too many bits!\");\n      }\n      if (signed) {\n        if (mBits < 32) {\n          if (a >>> (bits - 1)) {\n            a = ((1 << bits >>> 0) - a) * -1;\n          }\n        } else {\n          if (a / Math.pow(2, bits - 1) | 0) {\n            a = (Math.pow(2, bits) - a) * -1;\n          }\n        }\n      }\n      return a;\n    };\n\n    Bitstream.prototype.readLSB = function(bits, signed) {\n      var a, mBits;\n      if (bits === 0) {\n        return 0;\n      }\n      if (bits > 40) {\n        throw new Error(\"Too many bits!\");\n      }\n      mBits = bits + this.bitPosition;\n      a = (this.stream.peekUInt8(0)) >>> this.bitPosition;\n      if (mBits > 8) {\n        a |= (this.stream.peekUInt8(1)) << (8 - this.bitPosition);\n      }\n      if (mBits > 16) {\n        a |= (this.stream.peekUInt8(2)) << (16 - this.bitPosition);\n      }\n      if (mBits > 24) {\n        a += (this.stream.peekUInt8(3)) << (24 - this.bitPosition) >>> 0;\n      }\n      if (mBits > 32) {\n        a += (this.stream.peekUInt8(4)) * Math.pow(2, 32 - this.bitPosition);\n      }\n      if (mBits >= 32) {\n        a %= Math.pow(2, bits);\n      } else {\n        a &= (1 << bits) - 1;\n      }\n      if (signed) {\n        if (mBits < 32) {\n          if (a >>> (bits - 1)) {\n            a = ((1 << bits >>> 0) - a) * -1;\n          }\n        } else {\n          if (a / Math.pow(2, bits - 1) | 0) {\n            a = (Math.pow(2, bits) - a) * -1;\n          }\n        }\n      }\n      this.advance(bits);\n      return a;\n    };\n\n    Bitstream.prototype.peekLSB = function(bits, signed) {\n      var a, mBits;\n      if (bits === 0) {\n        return 0;\n      }\n      if (bits > 40) {\n        throw new Error(\"Too many bits!\");\n      }\n      mBits = bits + this.bitPosition;\n      a = (this.stream.peekUInt8(0)) >>> this.bitPosition;\n      if (mBits > 8) {\n        a |= (this.stream.peekUInt8(1)) << (8 - this.bitPosition);\n      }\n      if (mBits > 16) {\n        a |= (this.stream.peekUInt8(2)) << (16 - this.bitPosition);\n      }\n      if (mBits > 24) {\n        a += (this.stream.peekUInt8(3)) << (24 - this.bitPosition) >>> 0;\n      }\n      if (mBits > 32) {\n        a += (this.stream.peekUInt8(4)) * Math.pow(2, 32 - this.bitPosition);\n      }\n      if (mBits >= 32) {\n        a %= Math.pow(2, bits);\n      } else {\n        a &= (1 << bits) - 1;\n      }\n      if (signed) {\n        if (mBits < 32) {\n          if (a >>> (bits - 1)) {\n            a = ((1 << bits >>> 0) - a) * -1;\n          }\n        } else {\n          if (a / Math.pow(2, bits - 1) | 0) {\n            a = (Math.pow(2, bits) - a) * -1;\n          }\n        }\n      }\n      return a;\n    };\n\n    return Bitstream;\n\n  })();\n\n  module.exports = Bitstream;\n\n}).call(this);\n",
    "// Generated by CoffeeScript 1.10.0\n(function() {\n  var AVBuffer;\n\n  AVBuffer = (function() {\n    var BlobBuilder, URL;\n\n    function AVBuffer(input) {\n      var ref;\n      if (input instanceof Uint8Array) {\n        this.data = input;\n      } else if (input instanceof ArrayBuffer || Array.isArray(input) || typeof input === 'number' || ((ref = global.Buffer) != null ? ref.isBuffer(input) : void 0)) {\n        this.data = new Uint8Array(input);\n      } else if (input.buffer instanceof ArrayBuffer) {\n        this.data = new Uint8Array(input.buffer, input.byteOffset, input.length * input.BYTES_PER_ELEMENT);\n      } else if (input instanceof AVBuffer) {\n        this.data = input.data;\n      } else {\n        throw new Error(\"Constructing buffer with unknown type.\");\n      }\n      this.length = this.data.length;\n      this.next = null;\n      this.prev = null;\n    }\n\n    AVBuffer.allocate = function(size) {\n      return new AVBuffer(size);\n    };\n\n    AVBuffer.prototype.copy = function() {\n      return new AVBuffer(new Uint8Array(this.data));\n    };\n\n    AVBuffer.prototype.slice = function(position, length) {\n      if (length == null) {\n        length = this.length;\n      }\n      if (position === 0 && length >= this.length) {\n        return new AVBuffer(this.data);\n      } else {\n        return new AVBuffer(this.data.subarray(position, position + length));\n      }\n    };\n\n    BlobBuilder = global.BlobBuilder || global.MozBlobBuilder || global.WebKitBlobBuilder;\n\n    URL = global.URL || global.webkitURL || global.mozURL;\n\n    AVBuffer.makeBlob = function(data, type) {\n      var bb;\n      if (type == null) {\n        type = 'application/octet-stream';\n      }\n      try {\n        return new Blob([data], {\n          type: type\n        });\n      } catch (undefined) {}\n      if (BlobBuilder != null) {\n        bb = new BlobBuilder;\n        bb.append(data);\n        return bb.getBlob(type);\n      }\n      return null;\n    };\n\n    AVBuffer.makeBlobURL = function(data, type) {\n      return URL != null ? URL.createObjectURL(this.makeBlob(data, type)) : void 0;\n    };\n\n    AVBuffer.revokeBlobURL = function(url) {\n      return URL != null ? URL.revokeObjectURL(url) : void 0;\n    };\n\n    AVBuffer.prototype.toBlob = function() {\n      return AVBuffer.makeBlob(this.data.buffer);\n    };\n\n    AVBuffer.prototype.toBlobURL = function() {\n      return AVBuffer.makeBlobURL(this.data.buffer);\n    };\n\n    return AVBuffer;\n\n  })();\n\n  module.exports = AVBuffer;\n\n}).call(this);\n",
    "// Generated by CoffeeScript 1.10.0\n(function() {\n  var BufferList;\n\n  BufferList = (function() {\n    function BufferList() {\n      this.first = null;\n      this.last = null;\n      this.numBuffers = 0;\n      this.availableBytes = 0;\n      this.availableBuffers = 0;\n    }\n\n    BufferList.prototype.copy = function() {\n      var result;\n      result = new BufferList;\n      result.first = this.first;\n      result.last = this.last;\n      result.numBuffers = this.numBuffers;\n      result.availableBytes = this.availableBytes;\n      result.availableBuffers = this.availableBuffers;\n      return result;\n    };\n\n    BufferList.prototype.append = function(buffer) {\n      var ref;\n      buffer.prev = this.last;\n      if ((ref = this.last) != null) {\n        ref.next = buffer;\n      }\n      this.last = buffer;\n      if (this.first == null) {\n        this.first = buffer;\n      }\n      this.availableBytes += buffer.length;\n      this.availableBuffers++;\n      return this.numBuffers++;\n    };\n\n    BufferList.prototype.advance = function() {\n      if (this.first) {\n        this.availableBytes -= this.first.length;\n        this.availableBuffers--;\n        this.first = this.first.next;\n        return this.first != null;\n      }\n      return false;\n    };\n\n    BufferList.prototype.rewind = function() {\n      var ref;\n      if (this.first && !this.first.prev) {\n        return false;\n      }\n      this.first = ((ref = this.first) != null ? ref.prev : void 0) || this.last;\n      if (this.first) {\n        this.availableBytes += this.first.length;\n        this.availableBuffers++;\n      }\n      return this.first != null;\n    };\n\n    BufferList.prototype.reset = function() {\n      var results;\n      results = [];\n      while (this.rewind()) {\n        continue;\n      }\n      return results;\n    };\n\n    return BufferList;\n\n  })();\n\n  module.exports = BufferList;\n\n}).call(this);\n",
    "// Generated by CoffeeScript 1.10.0\n(function() {\n  var Base, EventEmitter,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty,\n    slice = [].slice;\n\n  Base = require('./base');\n\n  EventEmitter = (function(superClass) {\n    extend(EventEmitter, superClass);\n\n    function EventEmitter() {\n      return EventEmitter.__super__.constructor.apply(this, arguments);\n    }\n\n    EventEmitter.prototype.on = function(event, fn) {\n      var base;\n      if (this.events == null) {\n        this.events = {};\n      }\n      if ((base = this.events)[event] == null) {\n        base[event] = [];\n      }\n      return this.events[event].push(fn);\n    };\n\n    EventEmitter.prototype.off = function(event, fn) {\n      var events, index, ref;\n      if (this.events == null) {\n        return;\n      }\n      if ((ref = this.events) != null ? ref[event] : void 0) {\n        if (fn != null) {\n          index = this.events[event].indexOf(fn);\n          if (~index) {\n            return this.events[event].splice(index, 1);\n          }\n        } else {\n          return this.events[event];\n        }\n      } else if (event == null) {\n        return events = {};\n      }\n    };\n\n    EventEmitter.prototype.once = function(event, fn) {\n      var cb;\n      return this.on(event, cb = function() {\n        this.off(event, cb);\n        return fn.apply(this, arguments);\n      });\n    };\n\n    EventEmitter.prototype.emit = function() {\n      var args, event, fn, i, len, ref, ref1;\n      event = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      if (!((ref = this.events) != null ? ref[event] : void 0)) {\n        return;\n      }\n      ref1 = this.events[event].slice();\n      for (i = 0, len = ref1.length; i < len; i++) {\n        fn = ref1[i];\n        fn.apply(this, args);\n      }\n    };\n\n    return EventEmitter;\n\n  })(Base);\n\n  module.exports = EventEmitter;\n\n}).call(this);\n",
    "// Generated by CoffeeScript 1.10.0\n(function() {\n  var AVBuffer, BufferList, Stream, UnderflowError;\n\n  BufferList = require('./bufferlist');\n\n  AVBuffer = require('./buffer');\n\n  UnderflowError = require('./underflow');\n\n  Stream = (function() {\n    var buf, decodeString, float32, float64, float64Fallback, float80, int16, int32, int8, nativeEndian, uint16, uint32, uint8;\n\n    buf = new ArrayBuffer(16);\n\n    uint8 = new Uint8Array(buf);\n\n    int8 = new Int8Array(buf);\n\n    uint16 = new Uint16Array(buf);\n\n    int16 = new Int16Array(buf);\n\n    uint32 = new Uint32Array(buf);\n\n    int32 = new Int32Array(buf);\n\n    float32 = new Float32Array(buf);\n\n    if (typeof Float64Array !== \"undefined\" && Float64Array !== null) {\n      float64 = new Float64Array(buf);\n    }\n\n    nativeEndian = new Uint16Array(new Uint8Array([0x12, 0x34]).buffer)[0] === 0x3412;\n\n    function Stream(list1) {\n      this.list = list1;\n      this.localOffset = 0;\n      this.offset = 0;\n    }\n\n    Stream.fromBuffer = function(buffer) {\n      var list;\n      list = new BufferList;\n      list.append(buffer);\n      return new Stream(list);\n    };\n\n    Stream.prototype.copy = function() {\n      var result;\n      result = new Stream(this.list.copy());\n      result.localOffset = this.localOffset;\n      result.offset = this.offset;\n      return result;\n    };\n\n    Stream.prototype.available = function(bytes) {\n      return bytes <= this.list.availableBytes - this.localOffset;\n    };\n\n    Stream.prototype.remainingBytes = function() {\n      return this.list.availableBytes - this.localOffset;\n    };\n\n    Stream.prototype.advance = function(bytes) {\n      if (!this.available(bytes)) {\n        throw new UnderflowError();\n      }\n      this.localOffset += bytes;\n      this.offset += bytes;\n      while (this.list.first && this.localOffset >= this.list.first.length) {\n        this.localOffset -= this.list.first.length;\n        this.list.advance();\n      }\n      return this;\n    };\n\n    Stream.prototype.rewind = function(bytes) {\n      if (bytes > this.offset) {\n        throw new UnderflowError();\n      }\n      if (!this.list.first) {\n        this.list.rewind();\n        this.localOffset = this.list.first.length;\n      }\n      this.localOffset -= bytes;\n      this.offset -= bytes;\n      while (this.list.first.prev && this.localOffset < 0) {\n        this.list.rewind();\n        this.localOffset += this.list.first.length;\n      }\n      return this;\n    };\n\n    Stream.prototype.seek = function(position) {\n      if (position > this.offset) {\n        return this.advance(position - this.offset);\n      } else if (position < this.offset) {\n        return this.rewind(this.offset - position);\n      }\n    };\n\n    Stream.prototype.readUInt8 = function() {\n      var a;\n      if (!this.available(1)) {\n        throw new UnderflowError();\n      }\n      a = this.list.first.data[this.localOffset];\n      this.localOffset += 1;\n      this.offset += 1;\n      if (this.localOffset === this.list.first.length) {\n        this.localOffset = 0;\n        this.list.advance();\n      }\n      return a;\n    };\n\n    Stream.prototype.peekUInt8 = function(offset) {\n      var buffer;\n      if (offset == null) {\n        offset = 0;\n      }\n      if (!this.available(offset + 1)) {\n        throw new UnderflowError();\n      }\n      offset = this.localOffset + offset;\n      buffer = this.list.first;\n      while (buffer) {\n        if (buffer.length > offset) {\n          return buffer.data[offset];\n        }\n        offset -= buffer.length;\n        buffer = buffer.next;\n      }\n      return 0;\n    };\n\n    Stream.prototype.read = function(bytes, littleEndian) {\n      var i, j, k, ref, ref1;\n      if (littleEndian == null) {\n        littleEndian = false;\n      }\n      if (littleEndian === nativeEndian) {\n        for (i = j = 0, ref = bytes; j < ref; i = j += 1) {\n          uint8[i] = this.readUInt8();\n        }\n      } else {\n        for (i = k = ref1 = bytes - 1; k >= 0; i = k += -1) {\n          uint8[i] = this.readUInt8();\n        }\n      }\n    };\n\n    Stream.prototype.peek = function(bytes, offset, littleEndian) {\n      var i, j, k, ref, ref1;\n      if (littleEndian == null) {\n        littleEndian = false;\n      }\n      if (littleEndian === nativeEndian) {\n        for (i = j = 0, ref = bytes; j < ref; i = j += 1) {\n          uint8[i] = this.peekUInt8(offset + i);\n        }\n      } else {\n        for (i = k = 0, ref1 = bytes; k < ref1; i = k += 1) {\n          uint8[bytes - i - 1] = this.peekUInt8(offset + i);\n        }\n      }\n    };\n\n    Stream.prototype.readInt8 = function() {\n      this.read(1);\n      return int8[0];\n    };\n\n    Stream.prototype.peekInt8 = function(offset) {\n      if (offset == null) {\n        offset = 0;\n      }\n      this.peek(1, offset);\n      return int8[0];\n    };\n\n    Stream.prototype.readUInt16 = function(littleEndian) {\n      this.read(2, littleEndian);\n      return uint16[0];\n    };\n\n    Stream.prototype.peekUInt16 = function(offset, littleEndian) {\n      if (offset == null) {\n        offset = 0;\n      }\n      this.peek(2, offset, littleEndian);\n      return uint16[0];\n    };\n\n    Stream.prototype.readInt16 = function(littleEndian) {\n      this.read(2, littleEndian);\n      return int16[0];\n    };\n\n    Stream.prototype.peekInt16 = function(offset, littleEndian) {\n      if (offset == null) {\n        offset = 0;\n      }\n      this.peek(2, offset, littleEndian);\n      return int16[0];\n    };\n\n    Stream.prototype.readUInt24 = function(littleEndian) {\n      if (littleEndian) {\n        return this.readUInt16(true) + (this.readUInt8() << 16);\n      } else {\n        return (this.readUInt16() << 8) + this.readUInt8();\n      }\n    };\n\n    Stream.prototype.peekUInt24 = function(offset, littleEndian) {\n      if (offset == null) {\n        offset = 0;\n      }\n      if (littleEndian) {\n        return this.peekUInt16(offset, true) + (this.peekUInt8(offset + 2) << 16);\n      } else {\n        return (this.peekUInt16(offset) << 8) + this.peekUInt8(offset + 2);\n      }\n    };\n\n    Stream.prototype.readInt24 = function(littleEndian) {\n      if (littleEndian) {\n        return this.readUInt16(true) + (this.readInt8() << 16);\n      } else {\n        return (this.readInt16() << 8) + this.readUInt8();\n      }\n    };\n\n    Stream.prototype.peekInt24 = function(offset, littleEndian) {\n      if (offset == null) {\n        offset = 0;\n      }\n      if (littleEndian) {\n        return this.peekUInt16(offset, true) + (this.peekInt8(offset + 2) << 16);\n      } else {\n        return (this.peekInt16(offset) << 8) + this.peekUInt8(offset + 2);\n      }\n    };\n\n    Stream.prototype.readUInt32 = function(littleEndian) {\n      this.read(4, littleEndian);\n      return uint32[0];\n    };\n\n    Stream.prototype.peekUInt32 = function(offset, littleEndian) {\n      if (offset == null) {\n        offset = 0;\n      }\n      this.peek(4, offset, littleEndian);\n      return uint32[0];\n    };\n\n    Stream.prototype.readInt32 = function(littleEndian) {\n      this.read(4, littleEndian);\n      return int32[0];\n    };\n\n    Stream.prototype.peekInt32 = function(offset, littleEndian) {\n      if (offset == null) {\n        offset = 0;\n      }\n      this.peek(4, offset, littleEndian);\n      return int32[0];\n    };\n\n    Stream.prototype.readFloat32 = function(littleEndian) {\n      this.read(4, littleEndian);\n      return float32[0];\n    };\n\n    Stream.prototype.peekFloat32 = function(offset, littleEndian) {\n      if (offset == null) {\n        offset = 0;\n      }\n      this.peek(4, offset, littleEndian);\n      return float32[0];\n    };\n\n    Stream.prototype.readFloat64 = function(littleEndian) {\n      this.read(8, littleEndian);\n      if (float64) {\n        return float64[0];\n      } else {\n        return float64Fallback();\n      }\n    };\n\n    float64Fallback = function() {\n      var exp, frac, high, low, out, sign;\n      low = uint32[0], high = uint32[1];\n      if (!high || high === 0x80000000) {\n        return 0.0;\n      }\n      sign = 1 - (high >>> 31) * 2;\n      exp = (high >>> 20) & 0x7ff;\n      frac = high & 0xfffff;\n      if (exp === 0x7ff) {\n        if (frac) {\n          return NaN;\n        }\n        return sign * Infinity;\n      }\n      exp -= 1023;\n      out = (frac | 0x100000) * Math.pow(2, exp - 20);\n      out += low * Math.pow(2, exp - 52);\n      return sign * out;\n    };\n\n    Stream.prototype.peekFloat64 = function(offset, littleEndian) {\n      if (offset == null) {\n        offset = 0;\n      }\n      this.peek(8, offset, littleEndian);\n      if (float64) {\n        return float64[0];\n      } else {\n        return float64Fallback();\n      }\n    };\n\n    Stream.prototype.readFloat80 = function(littleEndian) {\n      this.read(10, littleEndian);\n      return float80();\n    };\n\n    float80 = function() {\n      var a0, a1, exp, high, low, out, sign;\n      high = uint32[0], low = uint32[1];\n      a0 = uint8[9];\n      a1 = uint8[8];\n      sign = 1 - (a0 >>> 7) * 2;\n      exp = ((a0 & 0x7F) << 8) | a1;\n      if (exp === 0 && low === 0 && high === 0) {\n        return 0;\n      }\n      if (exp === 0x7fff) {\n        if (low === 0 && high === 0) {\n          return sign * Infinity;\n        }\n        return NaN;\n      }\n      exp -= 16383;\n      out = low * Math.pow(2, exp - 31);\n      out += high * Math.pow(2, exp - 63);\n      return sign * out;\n    };\n\n    Stream.prototype.peekFloat80 = function(offset, littleEndian) {\n      if (offset == null) {\n        offset = 0;\n      }\n      this.peek(10, offset, littleEndian);\n      return float80();\n    };\n\n    Stream.prototype.readBuffer = function(length) {\n      var i, j, ref, result, to;\n      result = AVBuffer.allocate(length);\n      to = result.data;\n      for (i = j = 0, ref = length; j < ref; i = j += 1) {\n        to[i] = this.readUInt8();\n      }\n      return result;\n    };\n\n    Stream.prototype.peekBuffer = function(offset, length) {\n      var i, j, ref, result, to;\n      if (offset == null) {\n        offset = 0;\n      }\n      result = AVBuffer.allocate(length);\n      to = result.data;\n      for (i = j = 0, ref = length; j < ref; i = j += 1) {\n        to[i] = this.peekUInt8(offset + i);\n      }\n      return result;\n    };\n\n    Stream.prototype.readSingleBuffer = function(length) {\n      var result;\n      result = this.list.first.slice(this.localOffset, length);\n      this.advance(result.length);\n      return result;\n    };\n\n    Stream.prototype.peekSingleBuffer = function(offset, length) {\n      var result;\n      result = this.list.first.slice(this.localOffset + offset, length);\n      return result;\n    };\n\n    Stream.prototype.readString = function(length, encoding) {\n      if (encoding == null) {\n        encoding = 'ascii';\n      }\n      return decodeString.call(this, 0, length, encoding, true);\n    };\n\n    Stream.prototype.peekString = function(offset, length, encoding) {\n      if (offset == null) {\n        offset = 0;\n      }\n      if (encoding == null) {\n        encoding = 'ascii';\n      }\n      return decodeString.call(this, offset, length, encoding, false);\n    };\n\n    decodeString = function(offset, length, encoding, advance) {\n      var b1, b2, b3, b4, bom, c, end, littleEndian, nullEnd, pt, result, w1, w2;\n      encoding = encoding.toLowerCase();\n      nullEnd = length === null ? 0 : -1;\n      if (length == null) {\n        length = Infinity;\n      }\n      end = offset + length;\n      result = '';\n      switch (encoding) {\n        case 'ascii':\n        case 'latin1':\n          while (offset < end && (c = this.peekUInt8(offset++)) !== nullEnd) {\n            result += String.fromCharCode(c);\n          }\n          break;\n        case 'utf8':\n        case 'utf-8':\n          while (offset < end && (b1 = this.peekUInt8(offset++)) !== nullEnd) {\n            if ((b1 & 0x80) === 0) {\n              result += String.fromCharCode(b1);\n            } else if ((b1 & 0xe0) === 0xc0) {\n              b2 = this.peekUInt8(offset++) & 0x3f;\n              result += String.fromCharCode(((b1 & 0x1f) << 6) | b2);\n            } else if ((b1 & 0xf0) === 0xe0) {\n              b2 = this.peekUInt8(offset++) & 0x3f;\n              b3 = this.peekUInt8(offset++) & 0x3f;\n              result += String.fromCharCode(((b1 & 0x0f) << 12) | (b2 << 6) | b3);\n            } else if ((b1 & 0xf8) === 0xf0) {\n              b2 = this.peekUInt8(offset++) & 0x3f;\n              b3 = this.peekUInt8(offset++) & 0x3f;\n              b4 = this.peekUInt8(offset++) & 0x3f;\n              pt = (((b1 & 0x0f) << 18) | (b2 << 12) | (b3 << 6) | b4) - 0x10000;\n              result += String.fromCharCode(0xd800 + (pt >> 10), 0xdc00 + (pt & 0x3ff));\n            }\n          }\n          break;\n        case 'utf16-be':\n        case 'utf16be':\n        case 'utf16le':\n        case 'utf16-le':\n        case 'utf16bom':\n        case 'utf16-bom':\n          switch (encoding) {\n            case 'utf16be':\n            case 'utf16-be':\n              littleEndian = false;\n              break;\n            case 'utf16le':\n            case 'utf16-le':\n              littleEndian = true;\n              break;\n            case 'utf16bom':\n            case 'utf16-bom':\n              if (length < 2 || (bom = this.peekUInt16(offset)) === nullEnd) {\n                if (advance) {\n                  this.advance(offset += 2);\n                }\n                return result;\n              }\n              littleEndian = bom === 0xfffe;\n              offset += 2;\n          }\n          while (offset < end && (w1 = this.peekUInt16(offset, littleEndian)) !== nullEnd) {\n            offset += 2;\n            if (w1 < 0xd800 || w1 > 0xdfff) {\n              result += String.fromCharCode(w1);\n            } else {\n              if (w1 > 0xdbff) {\n                throw new Error(\"Invalid utf16 sequence.\");\n              }\n              w2 = this.peekUInt16(offset, littleEndian);\n              if (w2 < 0xdc00 || w2 > 0xdfff) {\n                throw new Error(\"Invalid utf16 sequence.\");\n              }\n              result += String.fromCharCode(w1, w2);\n              offset += 2;\n            }\n          }\n          if (w1 === nullEnd) {\n            offset += 2;\n          }\n          break;\n        default:\n          throw new Error(\"Unknown encoding: \" + encoding);\n      }\n      if (advance) {\n        this.advance(offset);\n      }\n      return result;\n    };\n\n    return Stream;\n\n  })();\n\n  module.exports = Stream;\n\n}).call(this);\n",
    "// Generated by CoffeeScript 1.10.0\n(function() {\n  var UnderflowError,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  UnderflowError = (function(superClass) {\n    extend(UnderflowError, superClass);\n\n    function UnderflowError() {\n      UnderflowError.__super__.constructor.apply(this, arguments);\n      this.name = 'UnderflowError';\n      this.stack = new Error().stack;\n    }\n\n    return UnderflowError;\n\n  })(Error);\n\n  module.exports = UnderflowError;\n\n}).call(this);\n",
    "// Generated by CoffeeScript 1.10.0\n(function() {\n  var Bitstream, BufferList, Decoder, EventEmitter, Stream, UnderflowError,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  EventEmitter = require('./core/events');\n\n  BufferList = require('./core/bufferlist');\n\n  Stream = require('./core/stream');\n\n  Bitstream = require('./core/bitstream');\n\n  UnderflowError = require('./core/underflow');\n\n  Decoder = (function(superClass) {\n    var codecs;\n\n    extend(Decoder, superClass);\n\n    function Decoder(demuxer, format) {\n      var list;\n      this.demuxer = demuxer;\n      this.format = format;\n      list = new BufferList;\n      this.stream = new Stream(list);\n      this.bitstream = new Bitstream(this.stream);\n      this.receivedFinalBuffer = false;\n      this.waiting = false;\n      this.demuxer.on('cookie', (function(_this) {\n        return function(cookie) {\n          var error, error1;\n          try {\n            return _this.setCookie(cookie);\n          } catch (error1) {\n            error = error1;\n            return _this.emit('error', error);\n          }\n        };\n      })(this));\n      this.demuxer.on('data', (function(_this) {\n        return function(chunk) {\n          list.append(chunk);\n          if (_this.waiting) {\n            return _this.decode();\n          }\n        };\n      })(this));\n      this.demuxer.on('end', (function(_this) {\n        return function() {\n          _this.receivedFinalBuffer = true;\n          if (_this.waiting) {\n            return _this.decode();\n          }\n        };\n      })(this));\n      this.init();\n    }\n\n    Decoder.prototype.init = function() {};\n\n    Decoder.prototype.setCookie = function(cookie) {};\n\n    Decoder.prototype.readChunk = function() {};\n\n    Decoder.prototype.decode = function() {\n      var error, error1, offset, packet;\n      this.waiting = !this.receivedFinalBuffer;\n      offset = this.bitstream.offset();\n      try {\n        packet = this.readChunk();\n      } catch (error1) {\n        error = error1;\n        if (!(error instanceof UnderflowError)) {\n          this.emit('error', error);\n          return false;\n        }\n      }\n      if (packet) {\n        this.emit('data', packet);\n        if (this.receivedFinalBuffer) {\n          this.emit('end');\n        }\n        return true;\n      } else if (!this.receivedFinalBuffer) {\n        this.bitstream.seek(offset);\n        this.waiting = true;\n      } else {\n        this.emit('end');\n      }\n      return false;\n    };\n\n    Decoder.prototype.seek = function(timestamp) {\n      var seekPoint;\n      seekPoint = this.demuxer.seek(timestamp);\n      this.stream.seek(seekPoint.offset);\n      return seekPoint.timestamp;\n    };\n\n    codecs = {};\n\n    Decoder.register = function(id, decoder) {\n      return codecs[id] = decoder;\n    };\n\n    Decoder.find = function(id) {\n      return codecs[id] || null;\n    };\n\n    return Decoder;\n\n  })(EventEmitter);\n\n  module.exports = Decoder;\n\n}).call(this);\n",
    "// Generated by CoffeeScript 1.10.0\n(function() {\n  var BufferList, Demuxer, EventEmitter, Stream,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  EventEmitter = require('./core/events');\n\n  BufferList = require('./core/bufferlist');\n\n  Stream = require('./core/stream');\n\n  Demuxer = (function(superClass) {\n    var formats;\n\n    extend(Demuxer, superClass);\n\n    Demuxer.probe = function(buffer) {\n      return false;\n    };\n\n    function Demuxer(source, chunk) {\n      var list, received;\n      list = new BufferList;\n      list.append(chunk);\n      this.stream = new Stream(list);\n      received = false;\n      source.on('data', (function(_this) {\n        return function(chunk) {\n          var e, error;\n          received = true;\n          list.append(chunk);\n          try {\n            return _this.readChunk(chunk);\n          } catch (error) {\n            e = error;\n            return _this.emit('error', e);\n          }\n        };\n      })(this));\n      source.on('error', (function(_this) {\n        return function(err) {\n          return _this.emit('error', err);\n        };\n      })(this));\n      source.on('end', (function(_this) {\n        return function() {\n          if (!received) {\n            _this.readChunk(chunk);\n          }\n          return _this.emit('end');\n        };\n      })(this));\n      this.seekPoints = [];\n      this.init();\n    }\n\n    Demuxer.prototype.init = function() {};\n\n    Demuxer.prototype.readChunk = function(chunk) {};\n\n    Demuxer.prototype.addSeekPoint = function(offset, timestamp) {\n      var index;\n      index = this.searchTimestamp(timestamp);\n      return this.seekPoints.splice(index, 0, {\n        offset: offset,\n        timestamp: timestamp\n      });\n    };\n\n    Demuxer.prototype.searchTimestamp = function(timestamp, backward) {\n      var high, low, mid, time;\n      low = 0;\n      high = this.seekPoints.length;\n      if (high > 0 && this.seekPoints[high - 1].timestamp < timestamp) {\n        return high;\n      }\n      while (low < high) {\n        mid = (low + high) >> 1;\n        time = this.seekPoints[mid].timestamp;\n        if (time < timestamp) {\n          low = mid + 1;\n        } else if (time >= timestamp) {\n          high = mid;\n        }\n      }\n      if (high > this.seekPoints.length) {\n        high = this.seekPoints.length;\n      }\n      return high;\n    };\n\n    Demuxer.prototype.seek = function(timestamp) {\n      var index, seekPoint;\n      if (this.format && this.format.framesPerPacket > 0 && this.format.bytesPerPacket > 0) {\n        seekPoint = {\n          timestamp: timestamp,\n          offset: this.format.bytesPerPacket * timestamp / this.format.framesPerPacket\n        };\n        return seekPoint;\n      } else {\n        index = this.searchTimestamp(timestamp);\n        return this.seekPoints[index];\n      }\n    };\n\n    formats = [];\n\n    Demuxer.register = function(demuxer) {\n      return formats.push(demuxer);\n    };\n\n    Demuxer.find = function(buffer) {\n      var e, error, format, i, len, offset, stream;\n      stream = Stream.fromBuffer(buffer);\n      for (i = 0, len = formats.length; i < len; i++) {\n        format = formats[i];\n        offset = stream.offset;\n        try {\n          if (format.probe(stream)) {\n            return format;\n          }\n        } catch (error) {\n          e = error;\n        }\n        stream.seek(offset);\n      }\n      return null;\n    };\n\n    return Demuxer;\n\n  })(EventEmitter);\n\n  module.exports = Demuxer;\n\n}).call(this);\n",
    "// Generated by CoffeeScript 1.10.0\n(function() {\n  var AudioDevice, EventEmitter,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  EventEmitter = require('./core/events');\n\n  AudioDevice = (function(superClass) {\n    var devices;\n\n    extend(AudioDevice, superClass);\n\n    function AudioDevice(sampleRate1, channels1) {\n      this.sampleRate = sampleRate1;\n      this.channels = channels1;\n      this.updateTime = bind(this.updateTime, this);\n      this.playing = false;\n      this.currentTime = 0;\n      this._lastTime = 0;\n    }\n\n    AudioDevice.prototype.start = function() {\n      if (this.playing) {\n        return;\n      }\n      this.playing = true;\n      if (this.device == null) {\n        this.device = AudioDevice.create(this.sampleRate, this.channels);\n      }\n      if (!this.device) {\n        throw new Error(\"No supported audio device found.\");\n      }\n      this._lastTime = this.device.getDeviceTime();\n      this._timer = setInterval(this.updateTime, 200);\n      return this.device.on('refill', this.refill = (function(_this) {\n        return function(buffer) {\n          return _this.emit('refill', buffer);\n        };\n      })(this));\n    };\n\n    AudioDevice.prototype.stop = function() {\n      if (!this.playing) {\n        return;\n      }\n      this.playing = false;\n      this.device.off('refill', this.refill);\n      return clearInterval(this._timer);\n    };\n\n    AudioDevice.prototype.destroy = function() {\n      var ref;\n      this.stop();\n      return (ref = this.device) != null ? ref.destroy() : void 0;\n    };\n\n    AudioDevice.prototype.seek = function(currentTime) {\n      this.currentTime = currentTime;\n      if (this.playing) {\n        this._lastTime = this.device.getDeviceTime();\n      }\n      return this.emit('timeUpdate', this.currentTime);\n    };\n\n    AudioDevice.prototype.updateTime = function() {\n      var time;\n      time = this.device.getDeviceTime();\n      this.currentTime += (time - this._lastTime) / this.device.sampleRate * 1000 | 0;\n      this._lastTime = time;\n      return this.emit('timeUpdate', this.currentTime);\n    };\n\n    devices = [];\n\n    AudioDevice.register = function(device) {\n      return devices.push(device);\n    };\n\n    AudioDevice.create = function(sampleRate, channels) {\n      var device, i, len;\n      for (i = 0, len = devices.length; i < len; i++) {\n        device = devices[i];\n        if (device.supported) {\n          return new device(sampleRate, channels);\n        }\n      }\n      return null;\n    };\n\n    return AudioDevice;\n\n  })(EventEmitter);\n\n  module.exports = AudioDevice;\n\n}).call(this);\n",
    "// Generated by CoffeeScript 1.10.0\n(function() {\n  var AVBuffer, AudioDevice, EventEmitter, MozillaAudioDevice,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  EventEmitter = require('../core/events');\n\n  AudioDevice = require('../device');\n\n  AVBuffer = require('../core/buffer');\n\n  MozillaAudioDevice = (function(superClass) {\n    var createTimer, destroyTimer;\n\n    extend(MozillaAudioDevice, superClass);\n\n    AudioDevice.register(MozillaAudioDevice);\n\n    MozillaAudioDevice.supported = (typeof Audio !== \"undefined\" && Audio !== null) && 'mozWriteAudio' in new Audio;\n\n    function MozillaAudioDevice(sampleRate, channels) {\n      this.sampleRate = sampleRate;\n      this.channels = channels;\n      this.refill = bind(this.refill, this);\n      this.audio = new Audio;\n      this.audio.mozSetup(this.channels, this.sampleRate);\n      this.writePosition = 0;\n      this.prebufferSize = this.sampleRate / 2;\n      this.tail = null;\n      this.timer = createTimer(this.refill, 100);\n    }\n\n    MozillaAudioDevice.prototype.refill = function() {\n      var available, buffer, currentPosition, written;\n      if (this.tail) {\n        written = this.audio.mozWriteAudio(this.tail);\n        this.writePosition += written;\n        if (this.writePosition < this.tail.length) {\n          this.tail = this.tail.subarray(written);\n        } else {\n          this.tail = null;\n        }\n      }\n      currentPosition = this.audio.mozCurrentSampleOffset();\n      available = currentPosition + this.prebufferSize - this.writePosition;\n      if (available > 0) {\n        buffer = new Float32Array(available);\n        this.emit('refill', buffer);\n        written = this.audio.mozWriteAudio(buffer);\n        if (written < buffer.length) {\n          this.tail = buffer.subarray(written);\n        }\n        this.writePosition += written;\n      }\n    };\n\n    MozillaAudioDevice.prototype.destroy = function() {\n      return destroyTimer(this.timer);\n    };\n\n    MozillaAudioDevice.prototype.getDeviceTime = function() {\n      return this.audio.mozCurrentSampleOffset() / this.channels;\n    };\n\n    createTimer = function(fn, interval) {\n      var url, worker;\n      url = AVBuffer.makeBlobURL(\"setInterval(function() { postMessage('ping'); }, \" + interval + \");\");\n      if (url == null) {\n        return setInterval(fn, interval);\n      }\n      worker = new Worker(url);\n      worker.onmessage = fn;\n      worker.url = url;\n      return worker;\n    };\n\n    destroyTimer = function(timer) {\n      if (timer.terminate) {\n        timer.terminate();\n        return URL.revokeObjectURL(timer.url);\n      } else {\n        return clearInterval(timer);\n      }\n    };\n\n    return MozillaAudioDevice;\n\n  })(EventEmitter);\n\n}).call(this);\n",
    "//JavaScript Audio Resampler\n//Copyright (C) 2011-2015 Grant Galitz\n//Released to Public Domain\nfunction Resampler(fromSampleRate, toSampleRate, channels, inputBufferLength) {\n  this.fromSampleRate = +fromSampleRate;\n  this.toSampleRate = +toSampleRate;\n  this.channels = channels | 0;\n  this.inputBufferLength = inputBufferLength;\n  this.initialize();\n}\n\nResampler.prototype.initialize = function () {\n  //Perform some checks:\n  if (this.fromSampleRate > 0 && this.toSampleRate > 0 && this.channels > 0) {\n    if (this.fromSampleRate == this.toSampleRate) {\n      //Setup a resampler bypass:\n      this.resampler = this.bypassResampler;    //Resampler just returns what was passed through.\n      this.ratioWeight = 1;\n    } else {\n      this.ratioWeight = this.fromSampleRate / this.toSampleRate;\n      if (this.fromSampleRate < this.toSampleRate) {\n        /*\n          Use generic linear interpolation if upsampling,\n          as linear interpolation produces a gradient that we want\n          and works fine with two input sample points per output in this case.\n        */\n        this.compileLinearInterpolationFunction();\n        this.lastWeight = 1;\n      } else {\n        /*\n          Custom resampler I wrote that doesn't skip samples\n          like standard linear interpolation in high downsampling.\n          This is more accurate than linear interpolation on downsampling.\n        */\n        this.compileMultiTapFunction();\n        this.tailExists = false;\n        this.lastWeight = 0;\n      }\n      \n      var outputBufferSize = (Math.ceil(this.inputBufferLength * this.toSampleRate / this.fromSampleRate / this.channels * 1.01) * this.channels) + this.channels;\n      this.outputBuffer = new Float32Array(outputBufferSize);\n      this.lastOutput = new Float32Array(this.channels);\n    }\n  } else {\n    throw(new Error(\"Invalid settings specified for the resampler.\"));\n  }\n};\n\nResampler.prototype.compileLinearInterpolationFunction = function () {\n  var toCompile = \"var outputOffset = 0;\\\n    var bufferLength = buffer.length;\\\n    if (bufferLength > 0) {\\\n      var weight = this.lastWeight;\\\n      var firstWeight = 0;\\\n      var secondWeight = 0;\\\n      var sourceOffset = 0;\\\n      var outputOffset = 0;\\\n      var outputBuffer = this.outputBuffer;\\\n      for (; weight < 1; weight += \" + this.ratioWeight + \") {\\\n        secondWeight = weight % 1;\\\n        firstWeight = 1 - secondWeight;\";\n        for (var channel = 0; channel < this.channels; ++channel) {\n          toCompile += \"outputBuffer[outputOffset++] = (this.lastOutput[\" + channel + \"] * firstWeight) + (buffer[\" + channel + \"] * secondWeight);\";\n        }\n      toCompile += \"}\\\n      weight -= 1;\\\n      for (bufferLength -= \" + this.channels + \", sourceOffset = Math.floor(weight) * \" + this.channels + \"; sourceOffset < bufferLength;) {\\\n        secondWeight = weight % 1;\\\n        firstWeight = 1 - secondWeight;\";\n        for (var channel = 0; channel < this.channels; ++channel) {\n          toCompile += \"outputBuffer[outputOffset++] = (buffer[sourceOffset\" + ((channel > 0) ? (\" + \" + channel) : \"\") + \"] * firstWeight) + (buffer[sourceOffset + \" + (this.channels + channel) + \"] * secondWeight);\";\n        }\n        toCompile += \"weight += \" + this.ratioWeight + \";\\\n        sourceOffset = Math.floor(weight) * \" + this.channels + \";\\\n      }\";\n      for (var channel = 0; channel < this.channels; ++channel) {\n        toCompile += \"this.lastOutput[\" + channel + \"] = buffer[sourceOffset++];\";\n      }\n      toCompile += \"this.lastWeight = weight % 1;\\\n    }\\\n    return this.outputBuffer;\";\n    \n  this.resampler = Function(\"buffer\", toCompile);\n};\n\nResampler.prototype.compileMultiTapFunction = function () {\n  var toCompile = \"var outputOffset = 0;\\\n    var bufferLength = buffer.length;\\\n    if (bufferLength > 0) {\\\n      var weight = 0;\";\n      for (var channel = 0; channel < this.channels; ++channel) {\n        toCompile += \"var output\" + channel + \" = 0;\"\n      }\n      toCompile += \"var actualPosition = 0;\\\n      var amountToNext = 0;\\\n      var alreadyProcessedTail = !this.tailExists;\\\n      this.tailExists = false;\\\n      var outputBuffer = this.outputBuffer;\\\n      var currentPosition = 0;\\\n      do {\\\n        if (alreadyProcessedTail) {\\\n          weight = \" + this.ratioWeight + \";\";\n          for (channel = 0; channel < this.channels; ++channel) {\n            toCompile += \"output\" + channel + \" = 0;\"\n          }\n        toCompile += \"}\\\n        else {\\\n          weight = this.lastWeight;\";\n          for (channel = 0; channel < this.channels; ++channel) {\n            toCompile += \"output\" + channel + \" = this.lastOutput[\" + channel + \"];\"\n          }\n          toCompile += \"alreadyProcessedTail = true;\\\n        }\\\n        while (weight > 0 && actualPosition < bufferLength) {\\\n          amountToNext = 1 + actualPosition - currentPosition;\\\n          if (weight >= amountToNext) {\";\n            for (channel = 0; channel < this.channels; ++channel) {\n              toCompile += \"output\" + channel + \" += buffer[actualPosition++] * amountToNext;\"\n            }\n            toCompile += \"currentPosition = actualPosition;\\\n            weight -= amountToNext;\\\n          }\\\n          else {\";\n            for (channel = 0; channel < this.channels; ++channel) {\n              toCompile += \"output\" + channel + \" += buffer[actualPosition\" + ((channel > 0) ? (\" + \" + channel) : \"\") + \"] * weight;\"\n            }\n            toCompile += \"currentPosition += weight;\\\n            weight = 0;\\\n            break;\\\n          }\\\n        }\\\n        if (weight <= 0) {\";\n          for (channel = 0; channel < this.channels; ++channel) {\n            toCompile += \"outputBuffer[outputOffset++] = output\" + channel + \" / \" + this.ratioWeight + \";\"\n          }\n        toCompile += \"}\\\n        else {\\\n          this.lastWeight = weight;\";\n          for (channel = 0; channel < this.channels; ++channel) {\n            toCompile += \"this.lastOutput[\" + channel + \"] = output\" + channel + \";\"\n          }\n          toCompile += \"this.tailExists = true;\\\n          break;\\\n        }\\\n      } while (actualPosition < bufferLength);\\\n    }\\\n    return this.outputBuffer;\";\n  \n  this.resampler = Function(\"buffer\", toCompile);\n};\n\nResampler.prototype.bypassResampler = function (inputBuffer) {\n  return inputBuffer;\n};\n\nmodule.exports = Resampler;\n",
    "// Generated by CoffeeScript 1.10.0\n(function() {\n  var AudioDevice, EventEmitter, Resampler, WebAudioDevice,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  EventEmitter = require('../core/events');\n\n  AudioDevice = require('../device');\n\n  Resampler = require('./resampler');\n\n  WebAudioDevice = (function(superClass) {\n    var AudioContext, createProcessor, sharedContext;\n\n    extend(WebAudioDevice, superClass);\n\n    AudioDevice.register(WebAudioDevice);\n\n    AudioContext = global.AudioContext || global.webkitAudioContext;\n\n    WebAudioDevice.supported = AudioContext && (typeof AudioContext.prototype[createProcessor = 'createScriptProcessor'] === 'function' || typeof AudioContext.prototype[createProcessor = 'createJavaScriptNode'] === 'function');\n\n    sharedContext = null;\n\n    function WebAudioDevice(sampleRate, channels1) {\n      this.sampleRate = sampleRate;\n      this.channels = channels1;\n      this.refill = bind(this.refill, this);\n      this.context = sharedContext != null ? sharedContext : sharedContext = new AudioContext;\n      this.deviceSampleRate = this.context.sampleRate;\n      this.bufferSize = Math.ceil(4096 / (this.deviceSampleRate / this.sampleRate) * this.channels);\n      this.bufferSize += this.bufferSize % this.channels;\n      if (this.deviceSampleRate !== this.sampleRate) {\n        this.resampler = new Resampler(this.sampleRate, this.deviceSampleRate, this.channels, this.bufferSize);\n      }\n      this.node = this.context[createProcessor](4096, this.channels, this.channels);\n      this.node.onaudioprocess = this.refill;\n      this.node.connect(this.context.destination);\n    }\n\n    WebAudioDevice.prototype.refill = function(event) {\n      var channelCount, channels, data, i, j, k, l, n, outputBuffer, ref, ref1, ref2;\n      outputBuffer = event.outputBuffer;\n      channelCount = outputBuffer.numberOfChannels;\n      channels = new Array(channelCount);\n      for (i = j = 0, ref = channelCount; j < ref; i = j += 1) {\n        channels[i] = outputBuffer.getChannelData(i);\n      }\n      data = new Float32Array(this.bufferSize);\n      this.emit('refill', data);\n      if (this.resampler) {\n        data = this.resampler.resampler(data);\n      }\n      for (i = k = 0, ref1 = outputBuffer.length; k < ref1; i = k += 1) {\n        for (n = l = 0, ref2 = channelCount; l < ref2; n = l += 1) {\n          channels[n][i] = data[i * channelCount + n];\n        }\n      }\n    };\n\n    WebAudioDevice.prototype.destroy = function() {\n      return this.node.disconnect(0);\n    };\n\n    WebAudioDevice.prototype.getDeviceTime = function() {\n      return this.context.currentTime * this.sampleRate;\n    };\n\n    return WebAudioDevice;\n\n  })(EventEmitter);\n\n}).call(this);\n",
    "// Generated by CoffeeScript 1.10.0\n(function() {\n  var Filter;\n\n  Filter = (function() {\n    function Filter(context, key) {\n      if (context && key) {\n        Object.defineProperty(this, 'value', {\n          get: function() {\n            return context[key];\n          }\n        });\n      }\n    }\n\n    Filter.prototype.process = function(buffer) {};\n\n    return Filter;\n\n  })();\n\n  module.exports = Filter;\n\n}).call(this);\n",
    "// Generated by CoffeeScript 1.10.0\n(function() {\n  var BalanceFilter, Filter,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  Filter = require('../filter');\n\n  BalanceFilter = (function(superClass) {\n    extend(BalanceFilter, superClass);\n\n    function BalanceFilter() {\n      return BalanceFilter.__super__.constructor.apply(this, arguments);\n    }\n\n    BalanceFilter.prototype.process = function(buffer) {\n      var i, j, pan, ref;\n      if (this.value === 0) {\n        return;\n      }\n      pan = Math.max(-50, Math.min(50, this.value));\n      for (i = j = 0, ref = buffer.length; j < ref; i = j += 2) {\n        buffer[i] *= Math.min(1, (50 - pan) / 50);\n        buffer[i + 1] *= Math.min(1, (50 + pan) / 50);\n      }\n    };\n\n    return BalanceFilter;\n\n  })(Filter);\n\n  module.exports = BalanceFilter;\n\n}).call(this);\n",
    "// Generated by CoffeeScript 1.10.0\n(function() {\n  var Filter, VolumeFilter,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  Filter = require('../filter');\n\n  VolumeFilter = (function(superClass) {\n    extend(VolumeFilter, superClass);\n\n    function VolumeFilter() {\n      return VolumeFilter.__super__.constructor.apply(this, arguments);\n    }\n\n    VolumeFilter.prototype.process = function(buffer) {\n      var i, j, ref, vol;\n      if (this.value >= 100) {\n        return;\n      }\n      vol = Math.max(0, Math.min(100, this.value)) / 100;\n      for (i = j = 0, ref = buffer.length; j < ref; i = j += 1) {\n        buffer[i] *= vol;\n      }\n    };\n\n    return VolumeFilter;\n\n  })(Filter);\n\n  module.exports = VolumeFilter;\n\n}).call(this);\n",
    "// Generated by CoffeeScript 1.10.0\n(function() {\n  var Asset, AudioDevice, BalanceFilter, EventEmitter, Player, Queue, VolumeFilter,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  EventEmitter = require('./core/events');\n\n  Asset = require('./asset');\n\n  VolumeFilter = require('./filters/volume');\n\n  BalanceFilter = require('./filters/balance');\n\n  Queue = require('./queue');\n\n  AudioDevice = require('./device');\n\n  Player = (function(superClass) {\n    extend(Player, superClass);\n\n    function Player(asset) {\n      this.asset = asset;\n      this.startPlaying = bind(this.startPlaying, this);\n      this.playing = false;\n      this.buffered = 0;\n      this.currentTime = 0;\n      this.duration = 0;\n      this.volume = 100;\n      this.pan = 0;\n      this.metadata = {};\n      this.filters = [new VolumeFilter(this, 'volume'), new BalanceFilter(this, 'pan')];\n      this.asset.on('buffer', (function(_this) {\n        return function(buffered) {\n          _this.buffered = buffered;\n          return _this.emit('buffer', _this.buffered);\n        };\n      })(this));\n      this.asset.on('decodeStart', (function(_this) {\n        return function() {\n          _this.queue = new Queue(_this.asset);\n          return _this.queue.once('ready', _this.startPlaying);\n        };\n      })(this));\n      this.asset.on('format', (function(_this) {\n        return function(format) {\n          _this.format = format;\n          return _this.emit('format', _this.format);\n        };\n      })(this));\n      this.asset.on('metadata', (function(_this) {\n        return function(metadata) {\n          _this.metadata = metadata;\n          return _this.emit('metadata', _this.metadata);\n        };\n      })(this));\n      this.asset.on('duration', (function(_this) {\n        return function(duration) {\n          _this.duration = duration;\n          return _this.emit('duration', _this.duration);\n        };\n      })(this));\n      this.asset.on('error', (function(_this) {\n        return function(error) {\n          return _this.emit('error', error);\n        };\n      })(this));\n    }\n\n    Player.fromURL = function(url, opts) {\n      return new Player(Asset.fromURL(url, opts));\n    };\n\n    Player.fromFile = function(file) {\n      return new Player(Asset.fromFile(file));\n    };\n\n    Player.fromBuffer = function(buffer) {\n      return new Player(Asset.fromBuffer(buffer));\n    };\n\n    Player.prototype.preload = function() {\n      if (!this.asset) {\n        return;\n      }\n      this.startedPreloading = true;\n      return this.asset.start(false);\n    };\n\n    Player.prototype.play = function() {\n      var ref;\n      if (this.playing) {\n        return;\n      }\n      if (!this.startedPreloading) {\n        this.preload();\n      }\n      this.playing = true;\n      return (ref = this.device) != null ? ref.start() : void 0;\n    };\n\n    Player.prototype.pause = function() {\n      var ref;\n      if (!this.playing) {\n        return;\n      }\n      this.playing = false;\n      return (ref = this.device) != null ? ref.stop() : void 0;\n    };\n\n    Player.prototype.togglePlayback = function() {\n      if (this.playing) {\n        return this.pause();\n      } else {\n        return this.play();\n      }\n    };\n\n    Player.prototype.stop = function() {\n      var ref;\n      this.pause();\n      this.asset.stop();\n      return (ref = this.device) != null ? ref.destroy() : void 0;\n    };\n\n    Player.prototype.seek = function(timestamp) {\n      var ref;\n      if ((ref = this.device) != null) {\n        ref.stop();\n      }\n      this.queue.once('ready', (function(_this) {\n        return function() {\n          var ref1, ref2;\n          if ((ref1 = _this.device) != null) {\n            ref1.seek(_this.currentTime);\n          }\n          if (_this.playing) {\n            return (ref2 = _this.device) != null ? ref2.start() : void 0;\n          }\n        };\n      })(this));\n      timestamp = (timestamp / 1000) * this.format.sampleRate;\n      timestamp = this.asset.decoder.seek(timestamp);\n      this.currentTime = timestamp / this.format.sampleRate * 1000 | 0;\n      this.queue.reset();\n      return this.currentTime;\n    };\n\n    Player.prototype.startPlaying = function() {\n      var frame, frameOffset;\n      frame = this.queue.read();\n      frameOffset = 0;\n      this.device = new AudioDevice(this.format.sampleRate, this.format.channelsPerFrame);\n      this.device.on('timeUpdate', (function(_this) {\n        return function(currentTime) {\n          _this.currentTime = currentTime;\n          return _this.emit('progress', _this.currentTime);\n        };\n      })(this));\n      this.refill = (function(_this) {\n        return function(buffer) {\n          var bufferOffset, filter, i, j, k, len, max, ref, ref1;\n          if (!_this.playing) {\n            return;\n          }\n          if (!frame) {\n            frame = _this.queue.read();\n            frameOffset = 0;\n          }\n          bufferOffset = 0;\n          while (frame && bufferOffset < buffer.length) {\n            max = Math.min(frame.length - frameOffset, buffer.length - bufferOffset);\n            for (i = j = 0, ref = max; j < ref; i = j += 1) {\n              buffer[bufferOffset++] = frame[frameOffset++];\n            }\n            if (frameOffset === frame.length) {\n              frame = _this.queue.read();\n              frameOffset = 0;\n            }\n          }\n          ref1 = _this.filters;\n          for (k = 0, len = ref1.length; k < len; k++) {\n            filter = ref1[k];\n            filter.process(buffer);\n          }\n          if (!frame) {\n            if (_this.queue.ended) {\n              _this.currentTime = _this.duration;\n              _this.emit('progress', _this.currentTime);\n              _this.emit('end');\n              _this.stop();\n            } else {\n              _this.device.stop();\n            }\n          }\n        };\n      })(this);\n      this.device.on('refill', this.refill);\n      if (this.playing) {\n        this.device.start();\n      }\n      return this.emit('ready');\n    };\n\n    Player.prototype.destroy = function() {\n      var ref, ref1;\n      this.stop();\n      if ((ref = this.device) != null) {\n        ref.off();\n      }\n      if ((ref1 = this.asset) != null) {\n        ref1.destroy();\n      }\n      return this.off();\n    };\n\n    return Player;\n\n  })(EventEmitter);\n\n  module.exports = Player;\n\n}).call(this);\n",
    "// Generated by CoffeeScript 1.10.0\n(function() {\n  var EventEmitter, Queue,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  EventEmitter = require('./core/events');\n\n  Queue = (function(superClass) {\n    extend(Queue, superClass);\n\n    function Queue(asset) {\n      this.asset = asset;\n      this.write = bind(this.write, this);\n      this.readyMark = 64;\n      this.finished = false;\n      this.buffering = true;\n      this.ended = false;\n      this.buffers = [];\n      this.asset.on('data', this.write);\n      this.asset.on('end', (function(_this) {\n        return function() {\n          return _this.ended = true;\n        };\n      })(this));\n      this.asset.decodePacket();\n    }\n\n    Queue.prototype.write = function(buffer) {\n      if (buffer) {\n        this.buffers.push(buffer);\n      }\n      if (this.buffering) {\n        if (this.buffers.length >= this.readyMark || this.ended) {\n          this.buffering = false;\n          return this.emit('ready');\n        } else {\n          return this.asset.decodePacket();\n        }\n      }\n    };\n\n    Queue.prototype.read = function() {\n      if (this.buffers.length === 0) {\n        return null;\n      }\n      this.asset.decodePacket();\n      return this.buffers.shift();\n    };\n\n    Queue.prototype.reset = function() {\n      this.buffers.length = 0;\n      this.buffering = true;\n      return this.asset.decodePacket();\n    };\n\n    return Queue;\n\n  })(EventEmitter);\n\n  module.exports = Queue;\n\n}).call(this);\n",
    "EventEmitter = require '../../core/events'\nAVBuffer = require '../../core/buffer'\n\nclass FileSource extends EventEmitter\n    constructor: (@file) ->\n        if not FileReader?\n            return @emit 'error', 'This browser does not have FileReader support.'\n        \n        @offset = 0\n        @length = @file.size\n        @chunkSize = 1 << 20\n        @file[@slice = 'slice'] or @file[@slice = 'webkitSlice'] or @file[@slice = 'mozSlice']\n            \n    start: ->\n        if @reader\n            return @loop() unless @active\n        \n        @reader = new FileReader\n        @active = true\n        \n        @reader.onload = (e) =>\n            buf = new AVBuffer(new Uint8Array(e.target.result))\n            @offset += buf.length\n        \n            @emit 'data', buf   \n            @active = false     \n            @loop() if @offset < @length\n        \n        @reader.onloadend = =>\n            if @offset is @length\n                @emit 'end'\n                @reader = null\n        \n        @reader.onerror = (e) =>\n            @emit 'error', e\n        \n        @reader.onprogress = (e) =>\n            @emit 'progress', (@offset + e.loaded) / @length * 100\n        \n        @loop()\n        \n    loop: ->\n        @active = true\n        endPos = Math.min(@offset + @chunkSize, @length)\n        \n        blob = @file[@slice](@offset, endPos)\n        @reader.readAsArrayBuffer(blob)\n        \n    pause: ->\n        @active = false\n        try\n          @reader?.abort()\n        \n    reset: ->\n        @pause()\n        @offset = 0\n\nmodule.exports = FileSource\n",
    "EventEmitter = require '../../core/events'\nAVBuffer = require '../../core/buffer'\n\nclass HTTPSource extends EventEmitter\n    constructor: (@url, @opts = {}) ->\n        @chunkSize = 1 << 20\n        @inflight = false\n        if @opts.length\n            @length = @opts.length\n        @reset()\n        \n    start: ->\n        if @length\n            return @loop() unless @inflight\n        \n        @inflight = true\n        @xhr = new XMLHttpRequest()\n        \n        @xhr.onload = (event) =>\n            @length = parseInt @xhr.getResponseHeader(\"Content-Length\")                \n            @inflight = false\n            @loop()\n        \n        @xhr.onerror = (err) =>\n            @pause()\n            @emit 'error', err\n            \n        @xhr.onabort = (event) =>\n            @inflight = false\n        \n        @xhr.open(\"HEAD\", @url, true)\n        @xhr.send(null)\n        \n    loop: ->\n        if @inflight or not @length\n            return @emit 'error', 'Something is wrong in HTTPSource.loop'\n            \n        @inflight = true\n        @xhr = new XMLHttpRequest()\n        \n        @xhr.onload = (event) =>\n            if @xhr.response\n                buf = new Uint8Array(@xhr.response)\n            else\n                txt = @xhr.responseText\n                buf = new Uint8Array(txt.length)\n                for i in [0...txt.length]\n                    buf[i] = txt.charCodeAt(i) & 0xff\n\n            buffer = new AVBuffer(buf)\n            @offset += buffer.length\n            \n            @emit 'data', buffer\n            @emit 'end' if @offset >= @length\n\n            @inflight = false\n            @loop() unless @offset >= @length\n            \n        @xhr.onprogress = (event) =>\n            @emit 'progress', (@offset + event.loaded) / @length * 100\n\n        @xhr.onerror = (err) =>\n            @emit 'error', err\n            @pause()\n\n        @xhr.onabort = (event) =>\n            @inflight = false\n\n        @xhr.open(\"GET\", @url, true)\n        @xhr.responseType = \"arraybuffer\"\n\n        endPos = Math.min(@offset + @chunkSize, @length - 1)\n        @xhr.setRequestHeader(\"If-None-Match\", \"webkit-no-cache\")\n        @xhr.setRequestHeader(\"Range\", \"bytes=#{@offset}-#{endPos}\")\n        @xhr.overrideMimeType('text/plain; charset=x-user-defined')\n        @xhr.send(null)\n        \n    pause: ->\n        @inflight = false\n        @xhr?.abort()\n        \n    reset: ->\n        @pause()\n        @offset = 0\n        \nmodule.exports = HTTPSource\n",
    "// Generated by CoffeeScript 1.10.0\n(function() {\n  var AVBuffer, BufferList, BufferSource, EventEmitter,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  EventEmitter = require('../core/events');\n\n  BufferList = require('../core/bufferlist');\n\n  AVBuffer = require('../core/buffer');\n\n  BufferSource = (function(superClass) {\n    var clearImmediate, setImmediate;\n\n    extend(BufferSource, superClass);\n\n    function BufferSource(input) {\n      this.loop = bind(this.loop, this);\n      if (input instanceof BufferList) {\n        this.list = input;\n      } else {\n        this.list = new BufferList;\n        this.list.append(new AVBuffer(input));\n      }\n      this.paused = true;\n    }\n\n    setImmediate = global.setImmediate || function(fn) {\n      return global.setTimeout(fn, 0);\n    };\n\n    clearImmediate = global.clearImmediate || function(timer) {\n      return global.clearTimeout(timer);\n    };\n\n    BufferSource.prototype.start = function() {\n      this.paused = false;\n      return this._timer = setImmediate(this.loop);\n    };\n\n    BufferSource.prototype.loop = function() {\n      this.emit('progress', (this.list.numBuffers - this.list.availableBuffers + 1) / this.list.numBuffers * 100 | 0);\n      this.emit('data', this.list.first);\n      if (this.list.advance()) {\n        return setImmediate(this.loop);\n      } else {\n        return this.emit('end');\n      }\n    };\n\n    BufferSource.prototype.pause = function() {\n      clearImmediate(this._timer);\n      return this.paused = true;\n    };\n\n    BufferSource.prototype.reset = function() {\n      this.pause();\n      return this.list.rewind();\n    };\n\n    return BufferSource;\n\n  })(EventEmitter);\n\n  module.exports = BufferSource;\n\n}).call(this);\n"
  ]
}